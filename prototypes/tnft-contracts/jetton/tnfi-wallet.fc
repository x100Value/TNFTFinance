#include "imports/stdlib.fc";

;; TEP-74 Jetton Wallet Contract

const int op::transfer = 0x0f8a7ea5;
const int op::internal_transfer = 0x178d4519;
const int op::burn = 0x595f07bc;
const int op::transfer_notification = 0x7362d09c;
const int op::burn_notification = 0x7bdd97de;
const int op::excesses = 0xd53276db;

const int error::unknown_op = 0x70;
const int error::access_denied = 0x71;
const int error::not_enough_balance = 0x72;

global int storage::balance;
global slice storage::owner_address;
global slice storage::minter_address;
global cell storage::jetton_wallet_code;

load_data() { 
    slice ds = get_data().begin_parse();
    storage::balance = ds~load_coins();
    storage::owner_address = load_msg_addr_from_slice(ds);
    storage::minter_address = load_msg_addr_from_slice(ds);
    storage::jetton_wallet_code = ds~load_ref();
    ds.end_parse();
}

save_data() { 
    set_data(
        begin_cell()
            .store_coins(storage::balance)
            .store_slice(storage::owner_address)
            .store_slice(storage::minter_address)
            .store_ref(storage::jetton_wallet_code)
        .end_cell()
    );
}

bounce_back(slice sender_address, int query_id) { 
    builder msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(sender_address)
        .store_coins(0)
        .store_uint(0, 1)
        .store_uint(1, 1)
        .store_ref(
            begin_cell()
                .store_uint(op::excesses, 32)
                .store_uint(query_id, 64)
            .end_cell()
        );
    send_raw_message(msg.end_cell(), 128);
}

send_transfer_notification(slice to_address, int amount, slice from_address, int query_id, cell forward_payload) { 
    builder msg_body = begin_cell()
        .store_uint(0x7362d09c, 32)
        .store_uint(query_id, 64)
        .store_coins(amount)
        .store_slice(from_address)
        .store_ref(forward_payload);

    builder msg = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(to_address)
        .store_coins(0)
        .store_uint(0, 1)
        .store_uint(1, 1)
        .store_ref(msg_body.end_cell());
    
    send_raw_message(msg.end_cell(), 64);
}

send_burn_notification(int amount, slice from_address, slice response_address, int query_id) { 
    builder msg_body = begin_cell()
        .store_uint(op::burn_notification, 32)
        .store_uint(query_id, 64)
        .store_coins(amount)
        .store_slice(from_address)
        .store_slice(response_address);

    builder msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(storage::minter_address)
        .store_coins(0)
        .store_uint(0, 1)
        .store_uint(1, 1)
        .store_ref(msg_body.end_cell());
    
    send_raw_message(msg.end_cell(), 64);
}

handle_transfer(int my_balance, int msg_value, slice in_msg_body, slice sender_address) { 
    throw_unless(error::access_denied, equal_slice_bits(sender_address, storage::owner_address));

    int query_id = in_msg_body~load_uint(64);
    int amount = in_msg_body~load_coins();
    throw_unless(error::not_enough_balance, storage::balance >= amount);
    
    slice to_address = load_msg_addr_from_slice(in_msg_body);
    slice response_address = load_msg_addr_from_slice(in_msg_body);
    cell custom_payload = load_opt_ref_from_slice(in_msg_body);
    int forward_ton_amount = in_msg_body~load_coins();
    cell forward_payload = in_msg_body~load_ref();

    storage::balance -= amount;
    save_data();
}

handle_internal_transfer(int my_balance, int msg_value, slice in_msg_body, slice sender_address) { 
    int query_id = in_msg_body~load_uint(64);
    int amount = in_msg_body~load_coins();
    slice from_address = load_msg_addr_from_slice(in_msg_body);
    slice response_address = load_msg_addr_from_slice(in_msg_body);
    int forward_ton_amount = in_msg_body~load_coins();
    cell forward_payload = in_msg_body~load_ref();

    storage::balance += amount;
    save_data();

    if (forward_ton_amount > 0) {
        send_transfer_notification(storage::owner_address, amount, from_address, query_id, forward_payload);
    }
    
    if (my_balance > 0) {
        bounce_back(response_address, query_id);
    }
}

handle_burn(int my_balance, int msg_value, slice in_msg_body, slice sender_address) { 
    throw_unless(error::access_denied, equal_slice_bits(sender_address, storage::owner_address));

    int query_id = in_msg_body~load_uint(64);
    int amount = in_msg_body~load_coins();
    throw_unless(error::not_enough_balance, storage::balance >= amount);
    
    slice response_address = load_msg_addr_from_slice(in_msg_body);
    cell custom_payload = load_opt_ref_from_slice(in_msg_body);

    storage::balance -= amount;
    save_data();

    send_burn_notification(amount, storage::owner_address, response_address, query_id);
}

recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) { 
    if (in_msg_body.slice_empty?()) { return (); }

    load_data();
    slice sender_address = in_msg_full.begin_parse().load_msg_addr();
    int op = in_msg_body~load_uint(32);

    if (op == op::transfer) { handle_transfer(my_balance, msg_value, in_msg_body, sender_address); return (); }
    if (op == op::internal_transfer) { handle_internal_transfer(my_balance, msg_value, in_msg_body, sender_address); return (); }
    if (op == op::burn) { handle_burn(my_balance, msg_value, in_msg_body, sender_address); return (); }

    throw(error::unknown_op);
}

(int, slice, slice, cell) get_wallet_data() method_id {
    load_data();
    return (
        storage::balance,
        storage::owner_address,
        storage::minter_address,
        storage::jetton_wallet_code
    );
}